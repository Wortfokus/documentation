"use strict";(self.webpackChunkwortfokus=self.webpackChunkwortfokus||[]).push([[8100],{8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}},9826:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"projects/project-quiz/architecture/release-design","title":"Release Design","description":"Since we will host our code on a provider like Hetzner and have our Code on Github, we will have the need of a workflow which is able to release our changes.","source":"@site/docs/projects/project-quiz/architecture/release-design.md","sourceDirName":"projects/project-quiz/architecture","slug":"/projects/project-quiz/architecture/release-design","permalink":"/documentation/docs/projects/project-quiz/architecture/release-design","draft":false,"unlisted":false,"editUrl":"https://github.com/Wortfokus/documentation/tree/main/docs/projects/project-quiz/architecture/release-design.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Release - Design"},"sidebar":"projectsSidebar","previous":{"title":"Architecture Overview","permalink":"/documentation/docs/projects/project-quiz/architecture/"},"next":{"title":"Full view","permalink":"/documentation/docs/projects/project-quiz/architecture/full-view"}}');var r=t(4848),o=t(8453);const s={sidebar_position:2,sidebar_label:"Release - Design"},a="Release Design",d={},c=[{value:"Github-Overview",id:"github-overview",level:2},{value:"Branching-Model",id:"branching-model",level:2},{value:"Automation with GitHub Actions",id:"automation-with-github-actions",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"release-design",children:"Release Design"})}),"\n",(0,r.jsxs)(n.p,{children:["Since we will host our code on a provider like ",(0,r.jsx)(n.a,{href:"https://www.hetzner.com/de/",children:"Hetzner"})," and have our Code on Github, we will have the need of a workflow which is able to release our changes."]}),"\n",(0,r.jsx)(n.p,{children:"The idea is that we use the possibility of Github Actions (not yet checked) and release the code directly into our dedicated servers."}),"\n",(0,r.jsx)(n.p,{children:"But first we have a small overview of our Github-Setup"}),"\n",(0,r.jsx)(n.h2,{id:"github-overview",children:"Github-Overview"}),"\n",(0,r.jsx)(n.p,{children:"We save our code on Github on a specific organization base.\nIn this organization we have repositories for our frontend and backend."}),"\n",(0,r.jsx)(n.p,{children:"With the help of Github Actions we should be able to set up a CI/CD-Pipeline.\nIt will deploy our code on the server."}),"\n",(0,r.jsx)(n.p,{children:"From there we have prepared the configuration, so that our Frontend is able to talk to the backend and our Backend with a database.\nEverything is on this server, since we want some privacy."}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart TD\n    subgraph GH[GitHub - Wortfokus Organisation]\n        FE[Frontend Repo<br/>Flutter]\n        BE[Backend Repo<br/>.NET]\n    end\n\n    subgraph CI[CI/CD - GitHub Actions]\n        BuildFE[Build & Test Frontend]\n        BuildBE[Build & Test Backend]\n        Deploy[Deploy auf Server]\n    end\n\n    %% Beziehungen\n    FE --\x3e|entwickelt in| BuildFE\n    BE --\x3e|entwickelt in| BuildBE\n\n    BuildFE --\x3e Deploy\n    BuildBE --\x3e Deploy"}),"\n",(0,r.jsx)(n.h2,{id:"branching-model",children:"Branching-Model"}),"\n",(0,r.jsx)(n.p,{children:"Our branching model is designed to ensure code quality and smooth releases:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"main-branch"}),": This is both the main and production branch. Any code merged here is automatically published, provided all checks pass and the code is correct. Only Administrators should be able to merge into this branch."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"developer branch"}),": Used for testing and training. Final bug fixes and testing are performed here before release. Once approved by the administrator, code is merged into the main branch."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"feature branches"}),": All issues and new features are developed in dedicated feature branches, named ",(0,r.jsx)(n.code,{children:"feature-<number>-<title>"}),". After completion and testing, a pull request is made against the developer branch."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"github-automation"}),": Automated checks are run before new code is added to maintain quality and correctness."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"automation-with-github-actions",children:"Automation with GitHub Actions"}),"\n",(0,r.jsx)(n.p,{children:"We use GitHub Actions to automate our workflows. These actions are triggered by events such as pull requests or merges. Defined workflows handle tasks like running tests, building the project, and deploying code to our servers. This ensures that every change is validated and released efficiently, reducing manual effort and minimizing errors."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);